	if (all_adjacency_tag) {

		// declarations for convenient use
		using std::vector;
		using std::string;

		// store multiple adjacencies
		vector<vector<string>> adjacencies;
		adjacencies.reserve(adjacencies_size);
		FileIO::read_all_adjacencies_from_txt(adjacencyFile, adjacencies);


		// for each adjacency in adjacencies, we perform akin operations as above
		// some optimization can be done (e.g. via lambda function to avoid code repeatness) if having time


		// needed vectors 
		// after the usage for each adjacency, call clear() method for next use
		// avoid repeated creation whenever possible

		//vector<JsonHandler> jhandles;  // hold jhandles, one jhandle for one building
		//vector<Nef_polyhedron> nefs; // hold the nefs
		//vector<Nef_polyhedron> expanded_nefs; // hold expanded nefs
		//vector<Shell_explorer> shell_explorers; // hold shells for big nef
		//
		//
		//jhandles.reserve(adjacency_size);
		//nefs.reserve(adjacency_size); // avoid reallocation, use reserve() whenever possible
		//expanded_nefs.reserve(adjacency_size);


		// for mark the output files
		unsigned int num_off = 1;
		unsigned int num_json = 1;

		// for tracking which adjacency is currently being processed
		unsigned int num_adjacency = 1;
		for (const auto& adjacency : adjacencies) {

			// track the adjacency - 1-based index, e.g. adjacency 1, adjacency 2, ...
			std::cout << "processing adjacency " << num_adjacency << " ...\n";


			// create big nef
			// ------------------------------------------------------------------------------------------------------------------		
			// read buildings
			std::vector<JsonHandler> jhandles;
			jhandles.reserve(adjacency_size); // use reserve() to avoid extra copies

			// get jhandles, one jhandle for each building
			if (print_building_info)std::cout << "------------------------ building(part) info ------------------------\n";
			for (const auto& building_name : adjacency) // get each building
			{
				JsonHandler jhandle;
				jhandle.read_certain_building(j, building_name, lod, datum); // read in the building
				jhandles.emplace_back(jhandle); // add to the jhandlers vector

				if (print_building_info) {
					jhandle.message();
				}
			}
			if (print_building_info)std::cout << "---------------------------------------------------------------------\n";

			/* begin counting */
			Timer timer; // count the run time

			/* build the nef and stored in nefs vector */
			std::vector<Nef_polyhedron> nefs; // hold the nefs
			nefs.reserve(adjacency_size); // avoid reallocation, use reserve() whenever possible
			for (const auto& jhdl : jhandles) {
				Build::build_nef_polyhedron(jhdl, nefs); // triangulation tag can be passed as parameters, set to true by default
			}std::cout << "there are " << nefs.size() << " " << "nef polyhedra in total" << '\n';

			/* perform minkowski sum operation and store expanded nefs in nefs_expanded vector */
			std::vector<Nef_polyhedron> expanded_nefs;
			expanded_nefs.reserve(adjacency_size); // avoid reallocation, use reserve() whenever possible

			/* performing minkowski operations -------------------------------------------------------------------------*/
			std::cout << "performing minkowski sum ... " << '\n';
			if (enable_multi_threading) {
				std::cout << "multi threading is enabled" << '\n';
				MT::expand_nefs_async(nefs, expanded_nefs, minkowski_param);
			}
			else {
				MT::expand_nefs(nefs, expanded_nefs, minkowski_param);
			}
			std::cout << "done" << '\n';
			/* building nefs and performing minkowski operations -------------------------------------------------------------------------*/

			// merging nefs into one big nef
			std::cout << "building big nef ..." << '\n';
			Nef_polyhedron big_nef;
			for (auto& nef : expanded_nefs) {
				big_nef += nef;
			}
			std::cout << "done" << '\n';
			// ------------------------------------------------------------------------------------------------------------------



			// ------------------------------------------------------------------------------------------------------------------
			// extract geometries and possible post-processing
			// extracting geometries
			std::vector<Shell_explorer> shell_explorers; // store the extracted geometries
			NefProcessing::extract_nef_geometries(big_nef, shell_explorers); // extract geometries of the bignef
			NefProcessing::process_shells_for_cityjson(shell_explorers); // process shells for writing to cityjson

			// remeshing
			if (enable_remeshing) {
				std::cout << "remeshing ...\n";
				std::string file = "remeshed.off";
				PostProcesssing::remeshing(big_nef, path + delimiter + file, target_edge_length);
				std::cout << "done\n";
			}
			// ------------------------------------------------------------------------------------------------------------------



			// output
			// ------------------------------------------------------------------------------------------------------------------ 
			// write file
			// json
			if (OUTPUT_JSON) {

				// get lod string
				std::string lod_string;
				if (std::abs(lod - 1.2) < epsilon)lod_string = "1.2";
				if (std::abs(lod - 1.3) < epsilon)lod_string = "1.3";
				if (std::abs(lod - 2.2) < epsilon)lod_string = "2.2";

				// get minkowski param string
				std::string mink_str = std::to_string(minkowski_param).substr(0, 5);

				// get the sequence of the file
				std::string num_str = std::to_string(num_json);

				// output
				std::string writeFilename = "lod=" + lod_string + "_" + "m=" + mink_str + "_" + num_str + ".json";
				const Shell_explorer& shell = shell_explorers[1]; // which shell is going to be written to the file, 0 - exterior, 1 - interior
				std::cout << "writing the result to cityjson file...\n";
				FileIO::write_JSON(path + delimiter + writeFilename, shell, lod);

				++num_json; // increment the file sequence
			}

			// write file
			// OFF
			if (OUTPUT_OFF) {

				// get lod string
				std::string lod_string;
				if (std::abs(lod - 1.2) < epsilon)lod_string = "1.2";
				if (std::abs(lod - 1.3) < epsilon)lod_string = "1.3";
				if (std::abs(lod - 2.2) < epsilon)lod_string = "2.2";

				// get minkowski param string
				std::string mink_str = std::to_string(minkowski_param).substr(0, 5);

				// get the sequence of the file
				std::string num_str = std::to_string(num_off);

				// output
				std::string writeFilename = "lod=" + lod_string + "_" + "m=" + mink_str + "_" + num_str + ".off";
				std::cout << "writing the result to OFF file...\n";
				bool status = FileIO::write_OFF(path + delimiter + writeFilename, big_nef);
				if (!status) {
					std::cerr << "can not write .off file, please check" << '\n';
					return 1;
				}

				++num_off; // increment the file sequence

			}
			// ------------------------------------------------------------------------------------------------------------------ 



			// vector cleaning for next use -------------------------------------------------------------------------------------


			// ------------------------------------------------------------------------------------------------------------------ 

			std::cout << "adjacency " << num_adjacency << " done\n";
			std::cout << '\n';
			++num_adjacency;
		} // end for: adjacencies


		// after processing all adjacencies, exit
		return EXIT_SUCCESS;

	}